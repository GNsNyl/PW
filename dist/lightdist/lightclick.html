<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Spectacular BOSTONELECTROPOLIS</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			@import url('https://fonts.googleapis.com/css2?family=Great+Vibes&family=Jura:wght@300&family=Poiret+One&family=Rubik+Maze&display=swap');
			</style>
	</head>
	<body>

		<div id="header">
			<h1>spectacular<br><br><br>BOSTONELECTROPOLIS</h1>
			<h2>CLICK components => turn on the lights, read and act in the dark!</h2>
			
		</div>
		<div id="sidebar">
				<h2 onclick="toggleTextproposition()" >proposition</h2>
				<h2 onclick="toggleTextgis()">gis interpolation</h2>
				<h2 onclick="toggleTextai()">ai classifier</h2>
		</div>
		<div class="videos">
			<video id="goegetown" src = "goegetownfinalresult.mp4" loop   autoplay="true" muted="muted" crossOrigin="anonymous" display = "none">
			</video>
			<video id="jamacaplain" src = "jamacaplainfinalresult.mp4" loop   autoplay="true" muted="muted" crossOrigin="anonymous" display = "none">
			</video>
			<video id="southboston" src = "southbostonfinalresult.mp4" loop   autoplay="true" muted="muted" crossOrigin="anonymous" display = "none">
			</video>
			<video id="summunt" src = "summuntfinalresult.mp4" loop   autoplay="true" muted="muted" crossOrigin="anonymous" display = "none">
			</video>
		  </div>

		<div id="info" class="panal">
			<div class = "closebutton" onclick="toggleTextproposition()" >CLOSE</div>
			<h2>information</h2>
			<p>key words: GIS, Land Use Code; Urban Asymmetry, Technological Mediation, Urban Psychology, Politics of Artifacts; Machine Learning</p>
			<p>year: 2022/08</p>
			<p>Artificial light breaks the most fundamental shackle of human activity– “the reduced activity in the dark.”

				<br><br>Being a pedestrian on the street at night, I have encountered numerous ‘’’awkward’’ moments when my presence was mistaken as some threatening figure of a bad guy, mostly to female pedestrians, within the very urban environment of dim light. 
				
				<br><br>As one of the earlier technological mediations of human life, artificial light is an example of the external change of the urban space weighing on the internal psychology of human beings.  To quote George Simmel: “to the extent that the metropolis creates these psychological conditions—with every crossing of the street, with the tempo and multiplicity of economic, occupational and social life—it creates in the sensory foundations of mental life, and in the degree of awareness necessitated by our organization as creatures dependent on differences…”
				
				<br><br>The spatial configuration of artificial light being an object of contestation and debate over the empowerment of and debilitation associated with the lack of it. The electropolis poses a stratified urban experience, and contributes to the sedimentation of the uneven distribution of resources. It complies to the first kind of scenario discussed by Langdon Winner in his Do Artifacts Have Politics, the technological artifacts are interwoven in the politics of “the social and economic system in which it is embedded.” 
				
				<br><br>The project factored in the participation of street light, urban land use, property type and ownership, economic activity of different kinds of urban space and their contribution into the urban secrecy. 
				
			  </p>
			  <p>notes:
				<br>1. Shaw Robert (2019). Artificial Light and the Modernist Redefinition of Urban Space.
				<br>2. Winner, Langdon (1980). Do artifacts have politics? Daedalus 109 (1):121--136.
			  </p>
			
		  </div>
		  <div id="technicality" class="panal">
			<div class = "closebutton" onclick="toggleTextgis()" >CLOSE</div>
			<h2>technicality</h2>
			<p>The map section interpolates the urban land use code, gis data of streetlight and demographic information of median income per block area.
				<br>light from the street buildings is calculated based on 251 types of property use code (vacant, industrial, commercial, school, single family house...) 
				, their average operating hours (for instance, restaurants open till 10pm, hospital will run 24/7...), and average light strength (strong from a parking building, but dimmer from a singlefamily building...)
			</p>
			
		  </div>
		  <div id="scenerio" class="panal">
			<div class = "closebutton" onclick="toggleTextai()" >CLOSE</div>
			<h2>scenerio</h2>
			<p>
			  #socialmediachallenge
			  <br>#day care center
			  <br>#anti-food commercials
			  <br>#anti-food porn
			  <br>
			  ...
			</p>
			
		  </div>
		<script>
				function toggleTextproposition(){
				  var x = document.getElementById("info");
				  var y = document.getElementById("technicality");
				  var z = document.getElementById("scenerio");
				  if (x.style.display === "none") {
					x.style.display = "block";
					y.style.display = "none";
					z.style.display = "none";
				  } else {
					x.style.display = "none";
				  }
				}
				function toggleTextgis(){
				  var x = document.getElementById("info");
				  var y = document.getElementById("technicality");
				  var z = document.getElementById("scenerio");
				 if (y.style.display === "none") {
					y.style.display = "block";
					x.style.display = "none";
					z.style.display = "none";
				  } else {
					y.style.display = "none";
				  }
				}
				function toggleTextai(){
				  var x = document.getElementById("info");
				  var y = document.getElementById("technicality");
				  var z = document.getElementById("scenerio");
				  if (z.style.display === "none") {
					x.style.display = "none";
					y.style.display = "none";
					z.style.display = "block";
				  } else {
					z.style.display = "none";
				  }
				}
		</script>
		<script type="x-shader/x-vertex" id="vertexshader">

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform sampler2D baseTexture;
			uniform sampler2D bloomTexture;

			varying vec2 vUv;

			void main() {

				gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

			}

		</script>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<!-- <script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		</script> -->

		<script type="module">

			import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';

			import { GUI } from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/libs/dat.gui.module.js';
			import { OrbitControls } from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/controls/OrbitControls.js'

			import { EffectComposer } from "https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/postprocessing/EffectComposer.js";
			import { RenderPass } from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/postprocessing/RenderPass.js';
			import { ShaderPass } from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/postprocessing/ShaderPass.js';
			import { UnrealBloomPass } from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/postprocessing/UnrealBloomPass.js';
			
			
			const ENTIRE_SCENE = 0, BLOOM_SCENE = 1;
			let videomap;
			let isShiftDown = false;
			const loader = new THREE.TextureLoader();

			const bloomLayer = new THREE.Layers();
			bloomLayer.set( BLOOM_SCENE );

			const params = {
				exposure: 1,
				bloomStrength: 5,
				bloomThreshold: 0,
				bloomRadius: 0,
				scene: 'Scene with Glow'
			};

			const darkMaterial = new THREE.MeshBasicMaterial( { color: 'black' } );
			const materials = {};

			const renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.toneMapping = THREE.ReinhardToneMapping;
			document.body.appendChild( renderer.domElement );

			const scene = new THREE.Scene();
			scene.autoUpdate=true;

			const camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 200 );
			camera.position.set( 0, 0, 100 );
			// camera.lookAt( 0, 0, 0 );

			const controls = new OrbitControls( camera, renderer.domElement );
			// controls.maxPolarAngle = Math.PI * 0.5;
			controls.minDistance = 1;
			controls.maxDistance = 200;
			controls.addEventListener( 'change', render );

			scene.add( new THREE.AmbientLight( 0x404040 ) );

			const renderScene = new RenderPass( scene, camera );

			const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
			bloomPass.threshold = params.bloomThreshold;
			bloomPass.strength = params.bloomStrength;
			bloomPass.radius = params.bloomRadius;

			const bloomComposer = new EffectComposer( renderer );
			bloomComposer.renderToScreen = false;
			bloomComposer.addPass( renderScene );
			bloomComposer.addPass( bloomPass );

			const finalPass = new ShaderPass(
				new THREE.ShaderMaterial( {
					uniforms: {
						baseTexture: { value: null },
						bloomTexture: { value: bloomComposer.renderTarget2.texture }
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					defines: {}
				} ), 'baseTexture'
			);
			finalPass.needsSwap = true;

			const finalComposer = new EffectComposer( renderer );
			finalComposer.addPass( renderScene );
			finalComposer.addPass( finalPass );

			const raycaster = new THREE.Raycaster();

			const mouse = new THREE.Vector2();
			// const bubblegroup = new THREE.Group();
			

			const objects=[];
       		const annotations=[];
			const bloomobject = [];
			// bubblegroup.add(objects);
			// scene.add(objects)



			window.addEventListener( 'pointerdown', onPointerDown );

			const gui = new GUI();

			gui.add( params, 'scene', [ 'Scene with Glow', 'Glow only', 'Scene only' ] ).onChange( function ( value ) {

				switch ( value ) 	{

					case 'Scene with Glow':
						bloomComposer.renderToScreen = false;
						break;
					case 'Glow only':
						bloomComposer.renderToScreen = true;
						break;
					case 'Scene only':
						// nothing to do
						break;

				}

				render();

			} );

			const folder = gui.addFolder( 'Bloom Parameters' );

			folder.add( params, 'exposure', 0.1, 2 ).onChange( function ( value ) {

				renderer.toneMappingExposure = Math.pow( value, 4.0 );
				render();

			} );

			folder.add( params, 'bloomThreshold', 0.0, 1.0 ).onChange( function ( value ) {

				bloomPass.threshold = Number( value );
				render();

			} );

			folder.add( params, 'bloomStrength', 0.0, 10.0 ).onChange( function ( value ) {

				bloomPass.strength = Number( value );
				render();

			} );

			folder.add( params, 'bloomRadius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {

				bloomPass.radius = Number( value );
				render();

			} );

			setupScene();
			addmapvideo();

			function onPointerDown( event ) {

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );
				const intersects = raycaster.intersectObjects( bloomobject, false );
				if ( intersects.length > 0 ) {

					const object = intersects[ 0 ].object;
					if (object !== videomap ) {
						object.layers.toggle( BLOOM_SCENE );
					render();
					}
					

				}

			}

			window.onresize = function () {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

				bloomComposer.setSize( width, height );
				finalComposer.setSize( width, height );

				render();

			};

            

			function setupScene() {

				scene.traverse( disposeMaterial );
				scene.children.length = 0;

				
				const bostongeo = new THREE.BoxGeometry(7,3,2);
				const bostontexture = [
					new THREE.MeshBasicMaterial( {color: 0xec1c4e} ),
					new THREE.MeshBasicMaterial( {color: 0xec1c4e} ),
					new THREE.MeshBasicMaterial( {color: 0xec1c4e} ),
					new THREE.MeshBasicMaterial( {color: 0xec1c4e} ),
					new THREE.MeshBasicMaterial( { map: loader.load("bostontext.png"), transparent:true } ),
					new THREE.MeshBasicMaterial( { map: loader.load("bostontext.png"), transparent:true } ),
					];
				const bostoncube = new THREE.Mesh(bostongeo,bostontexture);
				bostoncube.position.y=15;
				bostoncube.position.x=-15;
				bostoncube.position.z=15;
				
				const keywordgeo = new THREE.BoxGeometry(13,14);
				const keywordtexture = [
					new THREE.MeshBasicMaterial( {color: 0x00ff00} ),
					new THREE.MeshBasicMaterial( {color: 0x00ff00} ),
					new THREE.MeshBasicMaterial( {color: 0x00ff00} ),
					new THREE.MeshBasicMaterial( {color: 0x00ff00} ),
					new THREE.MeshBasicMaterial( { map: loader.load("keywords.png"), transparent:true } ),
					new THREE.MeshBasicMaterial( { map: loader.load("keywords.png"), transparent:true } ),
					];
				const keywordcube = new THREE.Mesh(keywordgeo,keywordtexture);
				keywordcube.position.z=5;
				keywordcube.position.y=-15;
				keywordcube.position.x=30;

				const clevegeo = new THREE.BoxGeometry(17,6);
				const clevetexture = [
					new THREE.MeshBasicMaterial( {color: 0xff26f4} ),
					new THREE.MeshBasicMaterial( {color: 0xff26f4} ),
					new THREE.MeshBasicMaterial( {color: 0xff26f4} ),
					new THREE.MeshBasicMaterial( {color: 0xff26f4} ),
					new THREE.MeshBasicMaterial( { map: loader.load("cleve.png"), transparent:true } ),
					new THREE.MeshBasicMaterial( { map: loader.load("cleve.png"), transparent:true } ),
					];
				const clevecube = new THREE.Mesh(clevegeo,clevetexture);
				clevecube.position.z=0;
				clevecube.position.y=-10;
				clevecube.position.x=45;


				const bookgeo = new THREE.BoxGeometry(21,6);
				const booktexture = [
					new THREE.MeshBasicMaterial( {color: 0xff0000} ),
					new THREE.MeshBasicMaterial( {color: 0xff0000} ),
					new THREE.MeshBasicMaterial( {color: 0xff0000} ),
					new THREE.MeshBasicMaterial( {color: 0xff0000} ),
					new THREE.MeshBasicMaterial( { map: loader.load("book.png"), transparent:true } ),
					new THREE.MeshBasicMaterial( { map: loader.load("book.png"), transparent:true } ),
					];
				const bookcube = new THREE.Mesh(bookgeo,booktexture);
				bookcube.position.z=10;
				bookcube.position.y=10;
				bookcube.position.x=30;

				const scenegeo = new THREE.BoxGeometry(23,23);
				const scenetexture = [
					new THREE.MeshBasicMaterial( {color: 0xffff00} ),
					new THREE.MeshBasicMaterial( {color: 0xffff00} ),
					new THREE.MeshBasicMaterial( {color: 0xffff00} ),
					new THREE.MeshBasicMaterial( {color: 0xffff00} ),
					new THREE.MeshBasicMaterial( { map: loader.load("lightscene.png"), transparent:true, alphatest:0.5 } ),
					new THREE.MeshBasicMaterial( { map: loader.load("lightscene.png"), transparent:true } ),
					];
				const scenecube = new THREE.Mesh(scenegeo,scenetexture);
				scenecube.position.z =-14;
				scenecube.position.y =-11;
				scenecube.position.x = 36;

				const maplist = ["latemap.png", "earlymap.png", "streetlightmap.png"];
				for(let i=0; i<maplist.length; i++) {
					
					var bosmaptabShape = new THREE.PlaneGeometry(38.4,29.4)
			
					var bostabmaterial = new THREE.MeshBasicMaterial({map: loader.load(maplist[i]), transparent:true});
					// bostabmaterial.alphaTest = 0.5;
					var bostab = new THREE.Mesh(bosmaptabShape, bostabmaterial);
					bostab.material.side = THREE.DoubleSide

					bostab.position.z= 2*i ;
					bostab.position.x=-30;
					bostab.position.y=-10;

					if ( Math.random() < 0.25 ) bostab.layers.enable( BLOOM_SCENE );
					// if ( Math.random() < 0.25 ) cubemap.layers.enable( BLOOM_SCENE );
					scene.add(bostab);
					bloomobject.push(bostab);
				};

				var bosmaptabShape2 = new THREE.PlaneGeometry(38.4,29.4);
			
					var bostbmaterial2 = new THREE.MeshBasicMaterial({map: loader.load("citymap.png"), transparent:true});
					bostabmaterial.alphaTest = 0.5;
					var bostab2 = new THREE.Mesh(bosmaptabShape2, bostbmaterial2);
					bostab2.material.side = THREE.DoubleSide

					bostab2.position.z= 8 ;
					bostab2.position.x=-30;
					bostab2.position.y=-10;

				if ( Math.random() < 1000 ) bostab2.layers.enable( BLOOM_SCENE );
					// if ( Math.random() < 0.25 ) cubemap.layers.enable( BLOOM_SCENE );
					scene.add(bostab2);
					bloomobject.push(bostab2);

				if ( Math.random() < 1000 ) bostoncube.layers.enable( BLOOM_SCENE );
				if ( Math.random() < 0.15 ) keywordcube.layers.enable( BLOOM_SCENE );
				if ( Math.random() < 1000 ) bookcube.layers.enable( BLOOM_SCENE );
				if ( Math.random() < 0.15 ) scenecube.layers.enable( BLOOM_SCENE );

				if ( Math.random() < 0.15 ) clevecube.layers.enable( BLOOM_SCENE );

				scene.add(bostoncube, keywordcube, bookcube, scenecube, clevecube);
				bloomobject.push(bostoncube, keywordcube, bookcube, scenecube, clevecube);
				let videomapgeo, videomapmaterial;

				

				videomapgeo = new THREE.PlaneGeometry(76.8,58.8);
				videomapmaterial = new THREE.MeshBasicMaterial({map: loader.load("videomap.png"), transparent:true});
				videomapmaterial.side= THREE.DoubleSide;
				videomap = new THREE.Mesh(videomapgeo, videomapmaterial);
				// videomap.rotation.y = Math.PI;
				videomap.position.x = 6;
				videomap.position.y =-5;
				videomap.position.z =-38;

				// if ( Math.random() < 0.15 ) videomap.layers.enable( BLOOM_SCENE );

				scene.add(videomap);
				
				

				const geometry = new THREE.IcosahedronGeometry( 1, 15 );

				for ( let i = 0; i < 30; i ++ ) {

					const color = new THREE.Color();
					color.setHSL( Math.random(), 0.7, Math.random() * 0.2 + 0.05 );
					const material = new THREE.MeshBasicMaterial( { color: color } );
					const sphere = new THREE.Mesh( geometry, material );
					sphere.position.x = -56+4*i;
					sphere.position.y = -25;
					sphere.position.z = 15;
					// sphere.position.x = Math.random() * 50 - 25;
					// sphere.position.y = Math.random() * 30 - 15;
					// sphere.position.z = Math.random() * 10 - 5;
					// sphere.position.normalize().multiplyScalar( Math.random() * 4.0 + 2.0 );
					// sphere.scale.setScalar( Math.random() * Math.random() + 0.5 );
					scene.add( sphere );
					bloomobject.push(sphere);
					if ( Math.random() < 10000000 ) sphere.layers.enable( BLOOM_SCENE );
				}
				render();
			}

			function disposeMaterial( obj ) {

				if ( obj.material ) {

					obj.material.dispose();

				}

			}

			function render() {

				switch ( params.scene ) {

					case 'Scene only':
						renderer.render( scene, camera );
						break;
					case 'Glow only':
						renderBloom( false );
						break;
					case 'Scene with Glow':
					default:
						// render scene with bloom
						renderBloom( true );

						// render the entire scene, then render bloom scene on top
						finalComposer.render();
						break;

				}

			}

			function renderBloom( mask ) {

				if ( mask === true ) {

					scene.traverse( darkenNonBloomed );
					bloomComposer.render();
					scene.traverse( restoreMaterial );

				} else {

					camera.layers.set( BLOOM_SCENE );
					bloomComposer.render();
					camera.layers.set( ENTIRE_SCENE );

				}

			}

			function darkenNonBloomed( obj ) {

				if ( obj.isMesh && bloomLayer.test( obj.layers ) === false ) {

					materials[ obj.uuid ] = obj.material;
					obj.material = darkMaterial;

				}

			}

			function restoreMaterial( obj ) {

				if ( materials[ obj.uuid ] ) {

					obj.material = materials[ obj.uuid ];
					delete materials[ obj.uuid ];

				}

			}

	function onPointerDownmap( event ) {

		mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

		raycaster.setFromCamera( mouse, camera );

					const intersects = raycaster.intersectObjects( objects, false );
					if ( intersects.length > 0 ) {
						const intersect = intersects[ 0 ];
						// if ( isShiftDown ){
							for (let a = 0; a<objects.length; a++){
							if (objects[a]===intersect.object) {
								scene.add(annotations[a])
							} 
							else{
								scene.remove(annotations[a])
							}
						}
						
						} else {
							scene.remove(annotations)
						// }
		}
	};
	window.addEventListener( 'pointerdown', onPointerDownmap );

function addmapvideo() {
	
	const videoidlist=["goegetown", "jamacaplain","southboston", "summunt" ];
	const videosrclist=["goegetownfinalresult.mp4", "jamacaplainfinalresult.mp4","southbostonfinalresult.mp4", "summuntfinalresult.mp4" ];
	const videoiconpositionxlist = [278/1600,501/1600,963/1600,718/1600];
	const videoiconpositionylist = [300/1200,580/1200,802/1200,787/1200];
	for (let i=0; i <videoidlist.length; i++){
		let video, videotexture, videogeometry, videomaterial, videoannotation;
		let videoicon, videoiconmaterial, videoicongeometry;

		video = document.getElementById( videoidlist[i] );
					video.src = videosrclist[i];
					video.load();
					video.play();

		videogeometry = new THREE.PlaneGeometry(12,8);

		videotexture = new THREE.VideoTexture( video );
		videomaterial = new THREE.MeshBasicMaterial({map: videotexture})
		videoannotation =  new THREE.Mesh(videogeometry, videomaterial);

		videoicongeometry = new THREE.BoxGeometry(2, 2, 2);
		videoiconmaterial = new THREE.MeshBasicMaterial({map:loader.load("cleve.png"), transparent:true});
		videoicon = new THREE.Mesh(videoicongeometry, videoiconmaterial);
		// videoicon.rotation
		// videoicon.position.x = 6;
		// videoicon.position.y=0;
		videoicon.position.x = videoiconpositionxlist[i]*75 + 6-0.5*75;
		videoicon.position.y = videoiconpositionylist[i]*55 -5 - 0.5*55;
		videoicon.position.z = -38; 
		//see videomap.position.z//

		videoannotation.position.copy(videoicon.position);
		videoannotation.position.y = videoannotation.position.y+0.5;
		videoannotation.position.z= videoannotation.position.z +1;
		videoicon.layers.enable( BLOOM_SCENE )

		objects.push(videoicon);
		// bubblegroup.add(videoicon);
		scene.add(videoicon)
		annotations.push(videoannotation)
	}
};
function onDocumentKeyDown( event ) {

switch ( event.keyCode ) {

	case 16: isShiftDown = true; break;

}

}

function onDocumentKeyUp( event ) {

switch ( event.keyCode ) {

	case 16: isShiftDown = false; break;

}

}

		</script>

	</body>

</html>
